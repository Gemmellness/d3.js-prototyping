<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <style>

        body {
            margin: 0;
            min-width: 800px;
            min-height: 600px;
        }

        rect {
            fill: none;
            pointer-events: all;
        }

        .node circle {
            width: 20px;
            height: 20px;
            r: 10;
        }

    </style>
</head>

<body onresize="resize()"><script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script>
    /* Magic numbers etc */
    var width = innerWidth,
        height = innerHeight;

    // Colours (solarized)
    var baseColours = ['#002b36', '#073642', '#586e75', '#657b83', '#839496', '#93a1a1', '#eee8d5', '#fdf6e3'],
        highlightColours = ['#b58900', '#cb4b16', '#dc322f', '#d33682', '#6c71c4', '#268bd2', '#2aa198', '#859900'];

    /* Assumptions about this data:
     *
     * The first node is the root
     * Every node's children are below it in the array
     *
     * */
    /*var nodeData = [{branch: "master", hash: "node0", children: [1]},
        {branch: "master", hash: "node1", children: [2]},
        {branch: "master", hash: "node2", children: [3,5]},
        {branch: "bugfix1", hash: "node3", children: [4]},
        {branch: "bugfix1", hash: "node4", children: [5]},
        {branch: "master", hash: "node5", children: [6,8]},
        {branch: "master", hash: "node6", children: []},
        {branch: "macversion", hash: "node7", children: [8]},
        {branch: "macversion", hash: "node8", children: []}];*/

    var nodeData = [{branch: "master", hash: "node0", children: [1]},
        {branch: "master", hash: "node1", children: [2]},
        {branch: "master", hash: "node2", children: [3]},
        {branch: "master", hash: "node3", children: []}];

    // Should be calculable from the graph
    var maxWidth = 1;

    // Add (stub) x & y values
    nodeData = nodeData.map(function (o) {o.x = 0; o.y = 0; return o;});

    /* Behaviours */
    // Zoom behaviour
    var zoom = d3.behavior.zoom()
            .scaleExtent([1, 10])
            .on("zoom", zoomed);

    // Drag behaviour
    var drag = d3.behavior.drag()
            .origin(function(d) { return d; })
            .on("dragstart", dragstarted)
            .on("drag", dragged)
            .on("dragend", dragended);

    /* Basic containers */
    // Place svg, set size
    var graph = d3.select("body")
            .style("background", baseColours[0])
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + 0 + "," + 0 + ")")
            .call(zoom);

    // Panning rectangle
    var rect = graph.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "none")
            .style("pointer-events", "all");

    var container = graph.append("g");

    // Create a vertical "channel" for each branch
    var dx;
    function updateChannels() {
        dx = d3.scale.linear()
                .domain([0, maxWidth+2])
                .range([0, width]);

    }
    updateChannels();

    // Vertical spacing of nodes
    var yScale = 60;

    // Verticle step of current node
    var yStep = 0;
    // Horizontal step of current node
    var xStep = 0;
    // Current branch number
    var branchNo = 0;
    // Last branch label (for
    var lastBranch = "";

    // Create nodes
    var nodes = container.append("g")
            .attr("class", "graph")
            .selectAll("nodes")
                .data(nodeData)
            .enter().append("g")
            .attr("class", "commit")
            .attr("transform", function(d){return "translate("+d.x+",80)"})
            .append("circle")
            .attr("r", 15)
            .attr("class", "node")
            .attr("hash", function(d) {return d.hash;})
            .attr("cx", function (d) {
                var cx = dx(xStep+1);
                d.x = cx;
                return cx;
            })
            .attr("cy", function (d) {
                var cy = yScale*(yStep+1);
                yStep++;
                d.y = cy;
                return cy;
            })
            .attr("fill", function (d){
                if(d.branch != lastBranch){
                    branchNo++;
                }

                lastBranch = d.branch;
                return highlightColours[branchNo % highlightColours.length];
            })
            .call(drag)
            .on("mouseover", function() {
                d3.select(this).attr("stroke", baseColours[1])
                        .attr("stroke-width", "1.5px");
            })
            .on('mouseout', function() {
                d3.select(this).attr("stroke-width", "0px");
            });

    var labels = container.selectAll(".commit")
            .append("text")
            .attr("class", "label")
            .attr("x", function (d) {return d.x+20})
            .attr("y", function (d) {return d.y+5;})
            .attr("font-family", "sans-serif")
            .attr("font-weight", "bold")
            .attr("fill", baseColours[6])
            .text(function (d) {return d.hash});

    function updateLabels () {
        labels.attr("x", function (d) {return d.x+20})
                .attr("y", function (d) {return d.y+5;});
    }

    function resize() {
        // Update size vars
        width = innerWidth;
        height = innerHeight;

        // Update svg
        d3.selectAll("svg")
                .attr("width", width)
                .attr("height", height);

        // Update linear scales
        updateChannels();

        // Update rect
        rect.attr("width", width)
            .attr("height", height);
    }

    function zoomed() {
        container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    function dragstarted(d) {
        d3.event.sourceEvent.stopPropagation();
        d3.select(this).classed("dragging", true);
    }

    function dragged(d) {
        d3.select(this).attr("cx", d.x = d3.event.x)
                .attr("cy", d.y = d3.event.y);
        updateLabels();
    }

    function dragended(d) {
        d3.select(this).classed("dragging", false);
    }

</script></body>